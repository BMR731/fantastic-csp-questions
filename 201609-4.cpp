//
// Created by Saijun Hu on 2019-02-25.
// TODO 此题加了额外的限制，为Dijstra算法改进版，不会,作为dij算法的例题。

/*数据量过大，需采用堆优化的dijkstra算法*/
#include <iostream>
#include <queue>
#include <vector>
#include <cstdio>

using namespace std;
int n,m;
struct edge
{
    int v;
    int cost;
    edge(int x,int c):v(x),cost(c){}
};
struct cmp
{
    bool operator()(edge &a,edge &b)
    {
        return a.cost>b.cost;
    }
};
vector<edge> vg[10000];
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;++i)
    {
        int x,y,w;
        scanf("%d %d %d",&x,&y,&w);
        --x,--y;
        vg[x].push_back(edge(y,w));
        vg[y].push_back(edge(x,w));
    }
    //dijkstra
    priority_queue<edge,vector<edge>,cmp> pq;
    vector<int> dist(n,INT_MAX);
    vector<int> cost(n,INT_MAX);
    vector<bool> visit(n,0);
    pq.push(edge(0,0));
    dist[0]=cost[0]=0;
    while(!pq.empty())
    {
        edge t=pq.top();//最短路径（花费）边
        pq.pop();
        visit[t.v]=1;//访问该节点
        for(size_t i=0;i<vg[t.v].size();++i)
        {
            edge e=vg[t.v][i];//该节点的所有邻接边
            if(visit[e.v])continue;//另外一端节点访问过了，跳过
            if(dist[e.v]>dist[t.v]+e.cost)//更新最短路径
            {
                dist[e.v]=dist[t.v]+e.cost;
                cost[e.v]=e.cost;
                pq.push(edge(e.v,dist[e.v]));//新的更新边
            }
            else if(dist[e.v]==dist[t.v]+e.cost)//本题对dijstra算法限制的体现处
            {
                cost[e.v]=min(cost[e.v],e.cost);
            }
        }
    }
    int sum=0;
    for(int i=0;i<n;++i)
        sum+=cost[i];
    printf("%d\n",sum);
    return 0;
}